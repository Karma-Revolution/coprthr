<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>STDCL Reference Manual</title>
  <meta name="generator" content="Amaya, see http://www.w3.org/Amaya/" />
  <style type="text/css" title="Amaya theme">
/* Modern style for Amaya Editor Lite */

/* default rules for the whole document */
body {
    font-size: 12pt;
    font-family: Times New Roman,Times,serif; /* Helvetica, Arial, sans-serif; */
    font-weight: normal;
    font-style: normal;
    color: black;
    background-color: white;
    line-height: 1.2em;
    margin-left: 4em;
    margin-right: 2em;
   }

/* paragraphs */
p  {
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
    text-align: left;
   }

/* headings */
h1 {
    font-size: 180%;
    font-weight: bold;
    font-style: normal;
    font-variant: small-caps;
    text-align: left;
    padding: 0;
    margin-top: 1.7em;
    margin-bottom: 1.7em;
   }
h2 {
    font-size: 150%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1.5em;
    margin-bottom: 1.1em;
   }
h3 {
    font-size: 130%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1.3em;
    margin-bottom: 1.1em;
   }
h4 {
    font-size: 110%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1.1em;
    margin-bottom: 1.1em;
   }
h5 {
    font-size: 100%;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
   }
h6 {
    font-size: 100%;
    font-weight: normal;
    font-style: italic;
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
   }

/* divisions */
div {
    padding: 0;
    margin-top: 0em;
    margin-bottom: 0em;
   }

/* lists */
ul, ol {
    padding: 0 0 0 3em;
    margin-top: 1em;
    margin-bottom: 1em;
   }
ul ul, ol ol, ul ol, ol ul {
    margin-top: 1em;
    margin-bottom: 1em;
   }
li {
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
    text-align: left;
   }
li p {
    margin-top: 1em;
    margin-bottom: 1em;
   }
dl {
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
    margin-left: 1em;
   }
dl dl {
    margin-top: 0em;
    margin-bottom: 0em;
   }
dt {
    padding: 0;
    font-weight: bold;
    margin-top: .3em;
    margin-bottom: .3em;
   }
dd {
    padding: 0;
    margin-top: .3em;
    margin-left: 3em;
    margin-bottom: .3em;
   }
dl p {
    margin-top: .3em;
    margin-bottom: .3em;
   }

/* inline */
strong {
    font-weight: bold;
   }
em {
    font-style: italic;
   }
code {
    font-family: Courier New, Courier, monospace;
   }
ins {
    background-color: yellow;
    text-decoration: underline;
   }
del {
    text-decoration: line-through;
   }

/* anchors */
a[href] {
    color: blue;
    text-decoration: underline;
   }

/* end */
  </style>
</head>

<body>
<p><img alt="" src="bdt_logo.jpg" width="201" height="70" /></p>

<h1 style="text-align:center;margin-left:auto;margin-right:auto;"><span
style="font-family: Times New Roman,Times,serif"><span
style="font-family: Arial,Helvetica,sans-serif">STDCL</span></span> </h1>

<h2 style="text-align:center;margin-left:auto;margin-right:auto;"><span
style="font-family: Times New Roman,Times,serif"><span
style="font-family: Arial,Helvetica,sans-serif">A Simplified C Interface for
OpenCL</span></span></h2>

<p style="text-align:center;margin-left:auto;margin-right:auto;">revision
1.4</p>

<p style="text-align:center;margin-left:auto;margin-right:auto;">Copyright ©
2009-2012 Brown Deer Technology, LLC</p>

<p style="text-align:center;margin-left:auto;margin-right:auto;"><span
style="font-size: 10pt"><span
style="font-family: Times New Roman,Times,serif"><em>Verbatim copying and
distribution of this entire document is </em></span></span><span
style="font-family: Times New Roman,Times,serif"><span
style="font-size: 10pt"><em>permitted </em></span></span><span
style="font-size: 10pt"><span
style="font-family: Times New Roman,Times,serif"><em>in any medium, provided
this notice is preserved.</em></span></span></p>
<hr />

<h2>Contents</h2>
<ul>
  <li><a href="#Name">Name</a></li>
  <li><a href="#Version">Version</a></li>
  <li><a href="#Synopsis">Synopsis</a></li>
  <li><a href="#Descriptio">Description</a></li>
  <li><a name="Applicatio1" id="Applicatio1" href="#Applicatio">Application
    Programming Interface (API)</a></li>
  <li style="margin-left:2em;"><a href="#Default">Default Contexts</a></li>
  <li style="margin-left:2em;"><a href="#Dynamic">Dynamic CL Program
  Loader</a></li>
  <li style="margin-left:2em;"><a href="#Memory">Memory Management</a></li>
  <li style="margin-left:2em;"><a href="#Kernel">Kernel Management</a></li>
  <li style="margin-left:2em;"><a href="#Synchroniz">Synchronization</a></li>
  <li style="margin-left:2em;"><a href="#Environmen">Environment
  Variables</a></li>
  <li><a href="#Examples">Examples</a></li>
  <li><a href="#Manual">Manual Pages</a></li>
</ul>
<hr />

<h2><a name="Name" id="Name">Name</a></h2>

<p><span style="font-family: Times New Roman,Times,serif"><span
style="font-family: Arial,Helvetica,sans-serif">STDCL - Standard Compute Layer
Interface</span></span></p>

<p></p>
<!-- <hr />

<h2><a name="Version" id="Version">Version</a></h2>

<p><span
style="font-family: Courier New,Courier,monospace">STDCL_VERSION_STR</span></p>

<p><span
style="font-family: Courier New,Courier,monospace">STDCL_VERSION_HEX</span></p>

<p></p> -->
<hr />

<h2><a name="Synopsis" id="Synopsis">Synopsis</a></h2>
<pre><span style="font-family: Courier New,Courier,monospace"><span style="font-family: Times New Roman,Times,serif">#include &lt;stdcl.h&gt;</span></span>

<span style="font-family: Times New Roman,Times,serif"><span style="font-family: Courier New,Courier,monospace">Link with -lstdcl.</span> </span></pre>
<dl>
  <dt>Default Contexts</dt>
    <dd><span style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">stddev, stdcpu,
      stdgpu, stdrpu,</span></span></span></dd>
    <dd><code>clgetndev()</code></dd>
  <dt>Dynamic CL Program loader</dt>
    <dd><span style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clopen(), clsym(),
      clclose(), clbuild()</span></span></span></dd>
  <dt>Memory Management</dt>
    <dd><span style="font-family: Courier New,Courier,monospace">clmalloc(),
      clmrealloc(), clfree(), clglmalloc(), </span></dd>
    <dd><span style="font-family: Courier New,Courier,monospace">clmctl(),
      clmctl_va(),</span></dd>
    <dd><span style="font-family: Courier New,Courier,monospace">clmattach(),
      clmdetach(), clsizeofmem(), clmsync(), clglmsync()</span></dd>
  <dt>Kernel Management</dt>
    <dd><span style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clndrange_init1d(),
      clndrange_init2d(), clndrange_init3d(),</span></span></span></span></dd>
    <dd style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clarg_set(),
      clarg_set_local(), clarg_set_global(), </span></dd>
    <dd><span style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clfork(),
      clforka()</span></span></span></span></dd>
  <dt>Synchronization</dt>
    <dd><span style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><code>clflush(),
      clwait()</code></span></span></dd>
  <dt>Environment Variables</dt>
    <dd>STDDEV, STDCPU, STDGPU, STDRPU,</dd>
    <dd>STD[DEV|CPU|GPU|RPU]_PLATFORM_NAME,</dd>
    <dd>STD[DEV|CPU|GPU|RPU]_MAX_NDEV,</dd>
    <dd>STD[DEV|CPU|GPU|RPU]_LOCK</dd>
  <dt></dt>
</dl>
<hr />

<h2><a name="Descriptio" id="Descriptio">Description</a></h2>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">OpenCL provides a host-side
API that allows the careful management of memory and processes on heterogeneous
computing platforms. The level of control is more typically reserved for
conventional operating systems (memory management, process management,
synchronization, etc.). Although this granularity of control is necessary to
support the expansive industry objectives for which OpenCL was designed, the
granularity of control and verbose nature of the API proves to be tedious
within the context of typical software application development. The steps
required for a simple Hello World OpenCL program are tedious and repetitive
from a programmer's perspective. Moreover, some semantics introduced by OpenCL
have more natural and familiar constructs within traditional UNIX programming
that can greatly simplify the use of the API and prove more efficient. As an
example, opaque memory buffers are more naturally managed as memory
allocations; modern UNIX-like operating systems are more than capable of
employing memory virtualization sufficient to allow control over memory
consistency. </span></p>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides a simplified C
interface to OpenCL designed in a style familiar to traditional UNIX/C
programmers. The design and implementation of STDCL is inspired by familiar
APIs designed for different purposes, e.g., stdio.h (for default contexts),
dlopen (for managing OpenCL kernels), malloc (as a replacement for creating
opaque memory buffers), and fork (as a replacement to "enqueueing commands on
the command queue"). In every detail, the approach is to avoid introducing new
inventive syntax and semantics in favor of exploiting permutations of more
familiar syntax and semantics from traditional UNIX. Whether the effort
succeeds is for the programmer to decide.</span></p>

<p></p>
<hr />

<h2><a name="Applicatio" id="Applicatio">Application Programming Interface
(API)</a></h2>

<p>The STDCL interface provides support for <a href="#Default"><em>default
contexts</em></a>, a <a href="#Dynamic"><em>dynamic CL program loader</em></a>,
<a href="#Memory"><em>memory management</em></a>, <a href="#Kernel"><em>kernel
execution</em></a>, and <em><a href="#Asynchrono">asynchronous
operations</a></em>. In addition, <a href="#Environmen">environment
variables</a> provide run-time control over certain aspects of the interface.
The STDCL interface is discussed in detail below. </p>

<p></p>

<h3><a name="Default" id="Default">Default Contexts</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides several default
contexts similar to the default I/O streams provided by stdio. These default
contexts are defined to include the most typical use-cases. Each default
context is of type </span><span
style="font-family: Courier New,Courier,monospace">CLCONTEXT,<span
style="font-family: Times New Roman,Times,serif"></span></span> <span
style="font-family: Times New Roman,Times,serif">which is defined as a superset
of the OpenCL type </span><span
style="font-family: Courier New,Courier,monospace">cl_context<span
style="font-family: Times New Roman,Times,serif"></span></span>. <span
style="font-family: Times New Roman,Times,serif">The following default contexts
are provided:</span></p>

<p><span style="font-family: Courier New,Courier,monospace"><strong>CLCONTEXT*
stddev;</strong></span> </p>

<p style="margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">All devices for a given
platform supported by the OpenCL API.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">CLCONTEXT*
stdcpu;</span></strong> </p>

<p style="margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">All multi-core CPU processors
for a given platform supported by the OpenCL API.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">CLCONTEXT*
stdgpu;</span></strong> </p>

<p style="margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">All many-core GPU processors
for a given platform supported by the OpenCL API.</span></p>

<p><span style="font-family: Courier New,Courier,monospace"><strong>CLCONTEXT*
stdrpu;</strong></span> </p>

<p style="margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">All reconfigurable processors
for a given platform supported by the OpenCL API.</span></p>

<p><strong><code>cl_uint clgetndev( CLCONTEXT* cp );</code></strong></p>

<p style="margin-left:2em;">This call returns the number of devices in the CL
context cp.</p>

<p><strong><code>void stdcl_init();</code></strong></p>

<p style="margin-left:2em;">This call should be made once prior to using the
default contexts. This call is required for Windows only. Linux and FreeBSD
will simply ignore the call.</p>

<p></p>

<h3><a name="Dynamic" id="Dynamic">Dynamic CL Program Loader</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides a convenient
interface for dynamically loading CL programs and accessing OpenCL kernels. The
functions <span
style="font-family: Courier New,Courier,monospace">clopen()</span>, <span
style="font-family: Courier New,Courier,monospace">clsym()</span> and <span
style="font-family: Courier New,Courier,monospace">clclose()</span> are
designed to mirror the semantics of the more familiar functions <span
style="font-family: Courier New,Courier,monospace">dlopen()</span>, <span
style="font-family: Courier New,Courier,monospace">dlsym()</span> and <span
style="font-family: Courier New,Courier,monospace">dlclose()</span> used to
access the Linux dynamic loader. The following functions are provided for
dynamically loading CL programs and accessing OpenCL kernels:</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">void*
clopen( CLCONTEXT* cp, const char* filename, int flags);</span></strong></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">This call opens a file
containing the source or binary program defining one or more OpenCL kernels and
performs the steps necessary to create and build the OpenCL program object. A
handle is returned that can be used in subsequent calls to access the actual
kernels in the program. The handle is valid within the</span> <span
style="font-family: Courier New,Courier,monospace">CLCONTEXT</span> <span
style="font-family: Times New Roman,Times,serif">specified by </span><span
style="font-family: Courier New,Courier,monospace"><strong>cp<span
style="font-family: Times New Roman,Times,serif"></span></strong></span>. </p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">The </span><strong><span
style="font-family: Courier New,Courier,monospace">flags<span
style="font-family: Times New Roman,Times,serif"></span></span></strong><span
style="font-family: Times New Roman,Times,serif">argument allows control over
the behavior of the function. The flag <span
style="font-family: Courier New,Courier,monospace">CLLD_NOW</span> instructs
the call to perform all of the steps involved with creating and building the
program; the flag <span
style="font-family: Courier New,Courier,monospace">CLLD_LAZY</span> instructs
the call to defer these steps until the handle is first used. The call accepts
a flag set to <span style="font-family: Courier New,Courier,monospace">0</span>
in which case the default behavior <span
style="font-family: Courier New,Courier,monospace">(CLLD_NOW)</span> is used.
</span></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">If the <strong>flags</strong>
argument <code>CLLD_NOBUILD</code> is used the compilation and build process is
deferred, and a subsequent call to <code>clbuild()</code> must be used for the
returned handle to reflect a valid (compiled and built) program. This flag is
useful when the user needs to pass in compiler options, which can be done with
the <code>clbuild()</code> call.</span></p>

<p style="margin-left:2em;">By default the following compiler options will
always be passed to the low-level OpenCL calls:</p>

<p style="margin-left:4em"><code>-D __STDCL__</code></p>

<p style="margin-left:4em"><code>-D __CPU__</code> | <code>__GPU__</code></p>

<p style="margin-left:4em"><code>-D __AMD__ | __NVIDIA__ |
__coprthr__</code></p>

<p style="margin-left:4em"><code>-I $(CWD)</code></p>

<p><strong><code>void* clsopen( CLCONTEXT* cp, const char* srcstr, int flags
);</code></strong></p>

<p style="margin-left:2em;">This call behaves exactly like
<code>clopen()</code> with the exception that instead of providing the name of
a file containing the OpenCL kernel source, the kernel code may be provided
directly as a string. This call can be useful within schemes where custom
kernel source is generated at run-time.</p>

<p><strong><span style="font-family: Courier New,Courier,monospace">cl_kernel
clsym( CLCONTEXT* cp, void* handle, const char* symbol, int
flags);</span></strong></p>

<p
style="margin-left:2em;text-align:justify;font-family: Times New Roman,Times,serif">This
call takes a <strong><span
style="font-family: Courier New,Courier,monospace">handle</span></strong>
returned from a call to <span
style="font-family: Courier New,Courier,monospace">clopen()</span> and returns
the OpenCL kernel specified by <strong><span
style="font-family: Courier New,Courier,monospace">symbol</span></strong>. The
OpenCL kernel is created within the <span
style="font-family: Courier New,Courier,monospace">CLCONTEXT</span> specified
by <strong>cp</strong>. </p>

<p style="margin-left:2em;">A null <strong>handle</strong> will cause the
dynamic loader to search for the kernel within the CL-ELF sections of the
executable itself.</p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">The argument <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> allows
control over the behavior of the function. The flag <span
style="font-family: Courier New,Courier,monospace">CLLD_NOW</span> instructs
the call to perform all of the steps involved with creating the kernel; the
flag <span style="font-family: Courier New,Courier,monospace">CLLD_LAZY</span>
instructs the call to defer these steps until the kernel is first used. The
call accepts a flag set to <span
style="font-family: Courier New,Courier,monospace">0</span> in which case the
default behavior <span
style="font-family: Courier New,Courier,monospace">(CLLD_NOW)</span> is
used.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">int
clclose( CLCONTEXT* cp, void* handle);</span></strong></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">This call decrements the
reference count on the associated handle. If the reference count drops to zero
then the associated OpenCL program source or binary is unloaded and the
associated file is closed. Under normal usage this call is used to safely
release the OpenCL programs created by a call to <span
style="font-family: Courier New,Courier,monospace">clopen()</span>.</span></p>

<p><strong><code>void* clbuild( CLCONTEXT* cp, void* handle, char* options, int
flags );</code></strong></p>

<p style="margin-left:2em;">This call is used following a call to
<code>clopen()</code> or <code>clsopen()</code> with the
<code>CLLD_NOBUILD</code> flag. Calling <code>clbuild()</code> will complete
the porocess of compilinng and building the kernel program. This call accepts
user-specified compiler options. The handle passed in must be a valid handle
created by a call to <code>clopen()</code> or <code>clsopen()</code> with the
<code>CLLD_NOBUILD</code> flag. <code></code>Calling <code>clbuild()</code>
will complete the porocess of compilinng and building the kernel program. This
call accepts user-specified compiler options. The handle passed in must be a
valid handle created by a call to <code>clopen()</code> or
<code>clsopen()</code> with the <code>CLLD_NOBUILD</code> flag. In addition to
the user defined compiler options, the standard compiler options described for
<code>clopen()</code> are also passed to low-level OpenCL calls.</p>

<p></p>

<h3><a name="Memory" id="Memory">Memory Management</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides functions for
allocating and managing memory that may be shared between the host and OpenCL
co-processor devices. Memory may be allocated with clmalloc() and used
transparently as the global memory for kernel execution on a OpenCL device. The
programmer uses a single pointer representing the allocated memory which may be
re-attached to various CL contexts using clmattach() and clmdetach(). Memory
consistency can be maintained using the clmsync() function which synchronizes
memory between the host and OpenCL co-processor devices. </span><span
style="font-family: Times New Roman,Times,serif">The following functions are
provided for OpenCL memory management.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">void*
clmalloc( CLCONTEXT* cp, size_t size, int flags);</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call allocates memory
suitable for sharing between OpenCL co-processor devices within a CL context.
The size of the allocation is specified in bytes. The memory is not cleared.
The last argument is used to pass flags to control the behavior of function.
The flag <span
style="font-family: Courier New,Courier,monospace">CL_MEM_DETACHED</span> may
be used to allocate memory that is not attached to a CL context in which case
<strong style="font-family: Courier New,Courier,monospace">cp</strong> must be
0. If <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> is 0
the default behavior is to allocate memory attached to a specified CL context.
</span></p>

<p><strong><code>void* clmrealloc( CLCONTEXT* cp, void* ptr, size_t size, int
flag);</code></strong></p>

<p style="margin-left:2em;">This call re-allocates memory suitable for sharing
between OpenCL co-processor devices within a CL context and may be used to
change the size of an existing allocation. The ptr argument must be a valid
memory allocation erturned by either <code>clmalloc()</code>, or a previous
call to <code>clmrealloc()</code>. The size of the allocation is specified in
bytes. The memory is not cleared. The last argument is used to pass flags to
control the behavior of function. The flag <span
style="font-family: Courier New,Courier,monospace">CL_MEM_DETACHED</span> may
be used to allocate memory that is not attached to a CL context in which case
<strong style="font-family: Courier New,Courier,monospace">cp</strong> must be
0. If <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> is 0
the default behavior is to allocate memory attached to a specified CL context.
</p>

<p><strong><code>void* clglmalloc( CLCONTEXT* cp, cl_GLuint glbufobj, cl_GLenum
target, cl_GLint miplevel, int flags);</code></strong></p>

<p style="margin-left:2em;">This call allocates memory suitable for sharing
between OpenCL co-processor devices within a CL context based on an existing
OpenGL memory object <strong><code>glbufobj</code></strong>. The OpenGL memory
object can be either a memory buffer, a 2D texture, a 3D texture or a render
buffer. The additional argunts <span
style="font-family: Courier New,Courier,monospace"><strong>target</strong></span>
and <strong><span
style="font-family: Courier New,Courier,monospace">miplevel</span></strong> are
used for textures and ignored oterwise. The size of the allocation is implied
by the OpenGL memory size. The memory is not cleared. The last argument
<strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> is
used to select the type of OpenGL memory object and control the behavior of
function. This argument must include one and only one of the following:
CL_MEM_GLBUF, CL_MEM_GLTEX2D, CL_MEM_GLTEX3D, CL_MEM_GLRBUF. The flag <span
style="font-family: Courier New,Courier,monospace">CL_MEM_DETACHED</span> may
be used to allocate memory that is not attached to a CL context in which case
<strong style="font-family: Courier New,Courier,monospace">cp</strong> must be
0. If <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> is 0
the default behavior is to allocate memory attached to a specified CL
context.</p>

<p><strong><span style="font-family: Courier New,Courier,monospace">void
clfree( void* ptr);</span></strong></p>

<p style="text-align:justify;margin-left:2em">This call frees memory allocated
with <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span>. The
memory specified by <strong><span
style="font-family: Courier New,Courier,monospace">ptr</span></strong> can be
either attached or detached from a CL context. Calling <span
style="font-family: Courier New,Courier,monospace">clfree()</span> with
<strong><span
style="font-family: Courier New,Courier,monospace">ptr</span></strong> equal to
<span style="font-family: Courier New,Courier,monospace">0</span> is considered
an error. </p>

<p><strong><span style="font-family: Courier New,Courier,monospace">size_t
clsizeofmem(void* ptr);</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call returns the size in
bytes of the memory allocated with <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span>.
</span></p>

<p><strong><code>int clmctl( void* ptr, int op, ... );</code></strong></p>

<p><code><strong>int clmctl_va( void* ptr, int op, va_list
);</strong></code></p>

<p style="margin-left:2em;">These calls provide generalized control over a
device-sharable memory allocation and differ only in the way optional arguments
are passed in. the <strong><code>ptr</code></strong> argument is a pointer to
device-sharable memory returned by any of the calls <code>clmalloc()</code>,
<code>clmrealloc(),</code> or <code>clglmalloc()</code>. The following
operations for the op argument are presently valid:</p>
<dl>
  <dt style="margin-left:2em;">CL_MCTL_SET_IMAGE2D</dt>
    <dd style="margin-left:4em">Mark the allocation to be of OpenCL image2d_t
      type. Optional arguments are: 
      <dl>
        <dt>size_t sz0</dt>
          <dd>Image width</dd>
        <dt>size_t sz1</dt>
          <dd>Image height </dd>
        <dt>size_t sz2</dt>
          <dd>Should be set to 0</dd>
        <dt>cl_image_format* fmt</dt>
          <dd>(Optional) pointer to image format struct, ignored if set to
          NULL</dd>
      </dl>
    </dd>
</dl>
<dl>
  <dt style="margin-left:2em;">CL_MCTL_SET_USRFLAGS</dt>
    <dd style="margin-left:4em">Set the cl_mem_flags bits for the allocation
      based on the user mem flags value passed in. This operation is only valid
      on a detached memory allocation. 
      <dl>
        <dt>cl_mem_flags usrflags</dt>
          <dd>User mem flags</dd>
      </dl>
    </dd>
</dl>
<dl>
  <dt style="margin-left:2em;">CL_MCTL_CLR_USRFLAGS</dt>
    <dd style="margin-left:4em">Clear the cl_mem_flags bits for the allocation
      based on the user mem flags value passed in. This operation is only valid
      on a detached memory allocation. 
      <dl>
        <dt>cl_mem_flags usrflags</dt>
          <dd>User mem flags</dd>
      </dl>
    </dd>
</dl>

<p><strong><span style="font-family: Courier New,Courier,monospace">cl_event
clmsync( CLCONTEXT* cp, unsigned int devnum, void* ptr, int
flags);</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call is used to
synchronize memory between the host platform and OpenCL co-processor devices.
The memory specified by <strong><span
style="font-family: Courier New,Courier,monospace">ptr</span></strong> must
have been allocated by <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span> or an
equivalent call and associated with a CL context. </span></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">The behavior of <span
style="font-family: Courier New,Courier,monospace">clmsync()</span> is
controlled by the <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong>
argument which must be set with either <span
style="font-family: Courier New,Courier,monospace">CL_MEM_HOST</span> or <span
style="font-family: Courier New,Courier,monospace">CL_MEM_DEVICE</span>. These
flags are mutually exclusive and it is an error to set both or none. In
addition the flags <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_WAIT</span> and
<span style="font-family: Courier New,Courier,monospace">CL_EVENT_NOWAIT</span>
control the blocking behavior for the call. For a blocking call the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span>
may be specified to prevent the call from releasing OpenCL events created as a
result of the call.</span><span
style="font-family: Times New Roman,Times,serif">If the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span> is
specified, the programmer is responsible for releasing the returned event with
the OpenCL call <span
style="font-family: Courier New,Courier,monospace">clReleaseEvent()</span>.</span></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">The following examples
demonstrate typical uses of <span
style="font-family: Courier New,Courier,monospace">clmsync()</span>:</span></p>

<p style="margin-left:2em;">Non-blocking sync to device memory:</p>

<p style=" margin-bottom: 0em; margin-top: 0em; ;margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clmsync(stdgpu,0,ptr,CL_MEM_DEVICE|CL_EVENT_NOWAIT);</span></p>

<p style="margin-left:2em;">Non-blocking sync to host memory:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clmsync(stdgpu,0,ptr,CL_MEM_HOST|CL_EVENT_NOWAIT);</span></p>

<p style="margin-left:2em;">Blocking sync to device memory:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clmsync(stdgpu,0,ptr,CL_MEM_DEVICE|CL_EVENT_WAIT);</span></p>

<p style="margin-left:2em;">Blocking sync to host with release of event:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clmsync(stdgpu,0,ptr,CL_MEM_HOST|CL_EVENT_WAIT);</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">cl_event
clmcopy( CLCONTEXT* cp, unsigned int devnum, void* src, void* dst, int
flags);</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call is used to copy
memory on an OpenCL device. The memory specified by <strong><span
style="font-family: Courier New,Courier,monospace">src</span></strong> and
<strong><span
style="font-family: Courier New,Courier,monospace">dst</span></strong> must
have been allocated by <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span> or an
equivalent call and associated with a CL context. </span></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">The behavior of <span
style="font-family: Courier New,Courier,monospace">clmcopy()</span> is
controlled by the <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong>
argument. The flags <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_WAIT</span> and
<span style="font-family: Courier New,Courier,monospace">CL_EVENT_NOWAIT</span>
control the blocking behavior for the call. For a blocking call the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span>
may be specified to prevent the call from releasing OpenCL events created as a
result of the call.</span><span
style="font-family: Times New Roman,Times,serif">If the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span> is
specified, the programmer is responsible for releasing the returned event with
the OpenCL call <span
style="font-family: Courier New,Courier,monospace">clReleaseEvent()</span>.</span></p>

<p><strong><code>cl_event clglmsync( CLCONTEXT* cp, unsigned int devnum, void*
ptr, int flags);</code></strong></p>

<p style="margin-left:2em;">This call is used to sync memory between
device-sharable memory and OpenGL buffers.</p>

<p style="margin-left:2em;">The flags argument must be set to either
CL_MEM_CLBUF or CL_MEM_GLBUF to define the destination of the sync
operation.</p>

<p><strong><span style="font-family: Courier New,Courier,monospace">int
clmattach( CLCONTEXT* cp, void* ptr );</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call is used to attach
memory allocated by <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span> to a CL
context. </span><span style="font-family: Times New Roman,Times,serif">In order
to change the attachment of memory from one CL context to another, the memory
must first be unattached using a call to <span
style="font-family: Courier New,Courier,monospace">clmdetach()</span>. It is an
error to call with a <strong><span
style="font-family: Courier New,Courier,monospace">ptr</span></strong> to
memory that is already attached to a CL context. </span></p>

<p><span style="font-family: Courier New,Courier,monospace"><strong>int
clmdetach( void* ptr );</strong></span></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call is used to detach
memory from a CL context. The memory must have been allocated by <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span>.</span></p>

<h3><a name="Kernel" id="Kernel">Kernel Management</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides simplified
interfaces for setting up the index-space and arguments for kernel execution.
Executing a kernel on an OpenCL co-processor device is supported using clfork()
which allows blocking and non-blocking execution behavior. The following
functions are provided for OpenCL kernel management.</span></p>

<p style="line-height:1em;"><strong><span
style="font-family: Courier New,Courier,monospace">clndrange_t
clndrange_init1d( gtoff0,gtsz0,ltsz0); <br />
clndrange_t clndrange_init2d( gtoff0,gtsz0,ltsz0, gtoff1,gtsz1,ltsz1); <br />
clndrange_t clndrange_init3d( gtoff0,gtsz0,ltsz0, gtoff1,gtsz1,ltsz1,
gtoff2,gtsz2,ltsz2);</span></strong></p>

<p style="margin-left:2em;text-align:justify;">The <span
style="font-family: Courier New,Courier,monospace">clndrange_init*()</span>
functions are used to <em>initialize</em> a variable of type <span
style="font-family: Courier New,Courier,monospace">clndrange_t</span> used to
store the OpenCL index-space over which a kernel is to execute. These functions
will be implemented as macros to allow for struct initialization in C. The
arguments <strong><span
style="font-family: Courier New,Courier,monospace">gtoff</span></strong>,
<strong><span
style="font-family: Courier New,Courier,monospace">gtsz</span></strong> and
<strong><span
style="font-family: Courier New,Courier,monospace">ltsz</span></strong>
represent the global offset, global size and local size of the index-space for
a given dimension, respectively. As an example, the following initializes a two
dimensional OpenCL NDRange with no offsets over a global index space of size
512 by 2048 with a local work group size of 4 by 16:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clndrange_t ndr =
clndrange_init2d( 0,512,4 0,2048,16);</span></p>

<p><strong style="font-family: Courier New,Courier,monospace">void clarg_set(
CLCONTEXT* cp, cl_kernel krn, unsigned int argnum, Tn arg );</strong></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">This call is used to set the
argument of an OpenCL kernel for arguments of intrinsic non-pointer type that
are to be passed by value. The size of the argument is inferred from the type
of the argument and may be a vector type, e.g., <span
style="font-family: Courier New,Courier,monospace">cl_float4</span>. </span></p>

<p><strong style="font-family: Courier New,Courier,monospace">void
clarg_set_global( CLCONTEXT* cp, cl_kernel krn, unsigned int argnum, void* ptr
);</strong></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">This call is used to set the
argument of an OpenCL kernel for arguments that are pointers to global memory
as defined in the OpenCL specification. The memory must have been allocated by
<span style="font-family: Courier New,Courier,monospace">clmalloc()</span> in
the appropriate CL context of the kernel. </span></p>

<p><strong style="font-family: Courier New,Courier,monospace">void
clarg_set_local( CLCONTEXT* cp, cl_kernel krn, unsigned int argnum, size_t
sizeb );</strong></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">This call is used to set the
argument of an OpenCL kernel for arguments that are pointers to local memory as
defined in the OpenCL specification. Local memory of size <strong><span
style="font-family: Courier New,Courier,monospace">sizeb</span></strong> bytes
will be allocated for use by the OpenCL kernel.</span></p>

<p><strong style="font-family: Courier New,Courier,monospace">cl_event clfork(
CLCONTEXT* cp, unsigned int devnum, cl_kernel krn, clndrange_t* ndr, int flags
);</strong></p>

<p><strong style="font-family: Courier New,Courier,monospace">cl_event clforka(
CLCONTEXT* cp, unsigned int devnum, cl_kernel krn, clndrange_t* ndr, int
flags</strong> [<strong style="font-family: Courier New,Courier,monospace">,
arg0, ..., argN </strong>]<strong
style="font-family: Courier New,Courier,monospace">);</strong></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">These calls are used to
execute a kernel on the OpenCL device specified by <strong><span
style="font-family: Courier New,Courier,monospace">devnum</span></strong>. In
the case of clfork() the kernel arguments must be set prior to the call using
the <span
style="font-family: Courier New,Courier,monospace">clarg_set*()</span>
functions described above. In the case of clforka() the kernel arguments may
simply be added, in correct order, to the calls argument list. The kernel is
executed over an index-space of work-items defined by <strong><span
style="font-family: Courier New,Courier,monospace">ndr</span></strong>.</span></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">The behavior of <span
style="font-family: Courier New,Courier,monospace">clfork()</span> may be
controlled using the flags <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_WAIT</span> or
<span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NOWAIT</span>.
Specifying the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NOWAIT</span> will
cause <span style="font-family: Courier New,Courier,monospace">clfork()</span>
to return immediately. Specifying the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_WAIT</span> will
cause <span style="font-family: Courier New,Courier,monospace">clfork()</span>
to block until the kernel execution is complete. Including the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span>
will prevent the event associated with the kernel execution to be released for
blocking calls to <span
style="font-family: Courier New,Courier,monospace">clfork()</span>. If the flag
<span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span> is
specified the programmer is responsible for releasing the returned event with
the OpenCL call <span
style="font-family: Courier New,Courier,monospace">clReleaseEvent()</span>.</span></p>

<p style="margin-left:2em;">The following examples demonstrate typical uses of
<span style="font-family: Courier New,Courier,monospace">clfork()</span> and
<span style="font-family: Courier New,Courier,monospace">clforka()</span>:</p>

<p style="margin-left:2em;">Blocking execution of a kernel on device number 0
automatically releasing the associated event:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clfork( stdgpu, 0, my_krn,
&amp;ndr, CL_EVENT_WAIT);</span></p>

<p style="margin-left:2em;">Non-blocking execution of a kernel on device number
2 automatically releasing the associated event:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clfork( stdgpu, 2, my_krn,
&amp;ndr, CL_EVENT_NOWAIT);</span></p>

<p style="margin-left:2em;">Blocking execution of a kernel on device number 0,
setting three kernel arguments a, b, and c, and automatically releasing the
associated event:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clforka( stdgpu, 0, my_krn,
&amp;ndr, CL_EVENT_WAIT, a, b, c );</span></p>

<p style="margin-left:2em;">Non-blocking execution of a kernel on device number
2, setting three kernel arguments a, b, and c, and automatically releasing the
associated event:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clforka( stdgpu, 2, my_krn,
&amp;ndr, CL_EVENT_NOWAIT, a, b, c);</span></p>

<p></p>

<h3><a name="Synchroniz" id="Synchroniz">Synchronization</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides functions for
synchronization to manage the inherently asynchronous operations enabled by
OpenCL per device within each CL context.</span></p>

<p><span style="font-family: Courier New,Courier,monospace"><strong>int
clflush( CLCONTEXT* cp, unsigned int devnum, int flags );</strong></span></p>

<p style="margin-left:2em;text-align:justify;">This call is used to flush all
commands enqueued in the command queue associated with the OpenCL device
specified by the device number <strong><span
style="font-family: Courier New,Courier,monospace">devnum</span></strong>
within the specified CL context. For typical OpenCL implementations this is
necessary to force the execution of commands without blocking on the host. A
call to <span
style="font-family: Courier New,Courier,monospace">clflush()</span> is
non-blocking and will return immediately. At present the argument <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> should
be set to <span style="font-family: Courier New,Courier,monospace">0</span>.</p>

<p><strong style="font-family: Courier New,Courier,monospace">cl_event clwait(
CLCONTEXT* cp, unsigned int devnum, int flags );</strong></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">This call is used to block on
the completion of all commands enqueued in the command queue associated with
the OpenCL device specified by the device number <strong><span
style="font-family: Courier New,Courier,monospace">devnum</span></strong>
within the specified CL context. </span></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">The <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong>
argument is used to control the behavior of the call as follows. The flag <span
style="font-family: Courier New,Courier,monospace">CL_KERNEL_EVENT</span> will
cause the call to block on completion of all enqueued kernel events enqueued by
calls to <span
style="font-family: Courier New,Courier,monospace">clfork()</span>. the flag
<span style="font-family: Courier New,Courier,monospace">CL_MEM_EVENT</span>
will cause the call to block on completion of all enqueued memory events
enqueued by call to <span
style="font-family: Courier New,Courier,monospace">clmsync()</span>. The flags
<span style="font-family: Courier New,Courier,monospace">CL_KERNEL_EVENT</span>
and <span
style="font-family: Courier New,Courier,monospace">CL_MEM_EVENT</span> may be
combined in a single call. Including the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span>
will prevent all OpenCL events to be released before <span
style="font-family: Courier New,Courier,monospace">clwait()</span>
returns.</span> If the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NORELEASE</span> is
specified the programmer is responsible for releasing all events with the
OpenCL call clReleaseEvent(). </p>

<p style="margin-left:2em;text-align:justify;">The following examples
demonstrate typical uses of <span
style="font-family: Courier New,Courier,monospace">clwait()</span>:</p>

<p style="margin-left:2em;">Block on completion of all kernel execution events
on OpenCL device number 0 releasing all events:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clwait( stdgpu, 0,
CL_KERNEL_EVENT );</span></p>

<p style="margin-left:2em;">Block on completion of all memory events on OpenCL
device number 2 releasing all events:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clwait( stdgpu, 2,
CL_MEM_EVENT );</span></p>

<p style="margin-left:2em;">Block on completion of all kernel and memory events
on OpenCL device number 2 releasing all events:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clwait( stdgpu, 2,
CL_ALL_EVENT );</span></p>

<p></p>

<h3><a name="Environmen" id="Environmen">Environment Variables</a></h3>

<p>The run-time behavior of STDCL can be controlled using environment variables
as follows.</p>

<p><strong><span style="font-family: Courier New,Courier,monospace">STDDEV,
</span></strong><span
style="font-family: Courier New,Courier,monospace"><strong>STDCPU,
</strong></span><span
style="font-family: Courier New,Courier,monospace"><strong>STDGPU,
</strong></span><span
style="font-family: Courier New,Courier,monospace"><strong>STDRPU</strong></span></p>

<p style="margin-left:2em;">Each default CL context is can be controlled by the
associated environment variable. A value of 0 or 1 will disable or enable the
context, respectively. The default behavior is to attempt to enable the context
if valid devices are available within the selected platform.</p>

<p
style="margin-left:0em"><strong><code>STD[DEV|CPU|GPU|RPU]_PLATFORM_NAME</code></strong></p>

<p style="margin-left:2em;">Set the platform name for the desired platform to
be used for a given context. If none is provided or the specified platform is
unavailable, a default will be selected.</p>

<p><strong><code>STD[DEV|CPU|GPU|RPU]_MAX_NDEV</code></strong></p>

<p style="margin-left:2em;">Set the maximum number of devices for a given
context regardless of whether more devices exist for the selected platform. If
there is an insufficient number of devices, the maximum available will be
provided.</p>

<p><strong><code>STD[DEV|CPU|GPU|RPU]_LOCK</code></strong></p>

<p style="margin-left:2em;">Set a lock ID for the process to enforce exclusive
access to the provided devices across all processes run with the same lock ID.
This feature is primarily useful to ensure the multiple MPI processes on a
multi-GPU platform are each given exclusive access to a GPU with no requirement
on the application itself.</p>

<p></p>
<hr />

<h2><a name="Examples" id="Examples">Examples</a></h2>

<p><span style="font-family: Times New Roman,Times,serif">The following example
shows the use of STDCL for a simple program that adds two vectors on a GPU or a
CPU:</span></p>

<div style="background-color:#e8e8e8;">
<pre>/* example #1 */

#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;
#include &lt;stdcl.h&gt;

#define SIZE 1024

int main()
{
   stdcl_init(); // requred for Windows only, Linux and FreeBSD will ignore this call

   int i;

   CLCONTEXT* cp = (stdgpu)? stdgpu : stdcpu;

   void* clh = clopen(cp, "add_vec.cl",CLLD_NOW);
   cl_kernel k_addvec = clsym(cp, clh, "addvec_kern", CLLD_NOW);

   float* aa = (float*)clmalloc(cp,SIZE*sizeof(float),0);
   float* bb = (float*)clmalloc(cp,SIZE*sizeof(float),0);
   float* cc = (float*)clmalloc(cp,SIZE*sizeof(float),0);

   for(i=0;i&lt;SIZE;i++) {
      aa[i] = 111.0f * i;
      bb[i] = 222.0f * i;
   }

   bzero(cc,SIZE*sizeof(float));

   clndrange_t ndr = clndrange_init1d(0,SIZE,64);

   clmsync(cp,0,aa,CL_MEM_DEVICE|CL_EVENT_NOWAIT);
   clmsync(cp,0,bb,CL_MEM_DEVICE|CL_EVENT_NOWAIT);

   clforka(cp,0,k_addvec,&amp;ndr,CL_EVENT_NOWAIT, aa, bb, cc);

   clmsync(cp,0,cc,CL_MEM_HOST|CL_EVENT_NOWAIT);

   clwait(cp,0,CL_MEM_EVENT|CL_KERNEL_EVENT);

   for(i=0;i&lt;SIZE;i++) printf("%f %f %f\n",aa[i],bb[i],cc[i]);

   if (aa) clfree(aa);
   if (bb) clfree(bb);
   if (cc) clfree(cc);

   clclose(cp,clh);
}
  </pre>
</div>

<p></p>

<p><span style="font-family: Times New Roman,Times,serif">The following example
shows the use of STDCL for a simple program that adds two vectors on two
GPUs:</span></p>

<div style="background-color:#e8e8e8;">
<pre>/* example #2 */

#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;
#include "stdcl.h"

#define SIZE 1024

int main()
{
   stdcl_init(); // required for Windows only, Linux and FreeBSD will ignore this call

   int i,n;

   CLCONTEXT* cp = stdgpu;

   void* clh = clopen(cp, "add_vec.cl",CLLD_NOW);
   cl_kernel k_addvec = clsym(cp, clh, "addvec_kern", CLLD_NOW);

   float* aa[2];
   float* bb[2];
   float* cc[2];

   aa[0] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   aa[1] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   bb[0] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   bb[1] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   cc[0] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   cc[1] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);

   for(i=0;i&lt;SIZE/2;i++) {
      aa[0][i] = 111.0f * i;
      aa[1][i] = 111.0f * (SIZE/2 + i);
      bb[0][i] = 222.0f * i;
      bb[1][i] = 222.0f * (SIZE/2 + i);
   }

   bzero(cc[0],SIZE*sizeof(float));
   bzero(cc[1],SIZE*sizeof(float));

   clndrange_t ndr = clndrange_init1d(0,SIZE/2,64);

   clmsync(cp,0,aa[0],CL_MEM_DEVICE|CL_EVENT_NOWAIT);
   clmsync(cp,1,aa[1],CL_MEM_DEVICE|CL_EVENT_NOWAIT);
   clmsync(cp,0,bb[0],CL_MEM_DEVICE|CL_EVENT_NOWAIT);
   clmsync(cp,1,bb[1],CL_MEM_DEVICE|CL_EVENT_NOWAIT);

   clarg_set_global(cp,k_addvec,0,aa[0]); 
   clarg_set_global(cp,k_addvec,1,bb[0]);
   clarg_set_global(cp,k_addvec,2,cc[0]);

   clfork(cp,0,k_addvec,&amp;ndr,CL_EVENT_NOWAIT); // clforka() could be used to elimiate the set-arg calls above

   clmsync(cp,0,cc[0],CL_MEM_HOST|CL_EVENT_NOWAIT);

   clflush(cp,0,0);

   clarg_set_global(cp,k_addvec,0,aa[1]);
   clarg_set_global(cp,k_addvec,1,bb[1]);
   clarg_set_global(cp,k_addvec,2,cc[1]);

   clfork(cp,1,k_addvec,&amp;ndr,CL_EVENT_NOWAIT); // clforka() could be used to elimiate the set-arg calls above

   clmsync(cp,1,cc[1],CL_MEM_HOST|CL_EVENT_NOWAIT);

   clflush(cp,1,0);

   clwait(cp,0,CL_MEM_EVENT|CL_KERNEL_EVENT);
   clwait(cp,1,CL_MEM_EVENT|CL_KERNEL_EVENT);

   for(i=0;i&lt;SIZE/2;i++) printf("%f %f %f\n",aa[0][i],bb[0][i],cc[0][i]);
   for(i=0;i&lt;SIZE/2;i++) printf("%f %f %f\n",aa[1][i],bb[1][i],cc[1][i]);

   if (aa[0]) clfree(aa[0]);
   if (aa[1]) clfree(aa[1]);
   if (bb[0]) clfree(bb[0]);
   if (bb[1]) clfree(bb[1]);
   if (cc[0]) clfree(cc[0]);
   if (cc[1]) clfree(cc[1]);

   clclose(cp,clh);
}
  </pre>
</div>

<p></p>
<hr />

<p></p>
</body>
</html>
